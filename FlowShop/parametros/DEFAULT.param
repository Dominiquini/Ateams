/* Caso algum atributo seja omitido ou definido como '-1', será usado o seu valor padrão! */

*ATEAMS*
[iterAteams] = 250		// Número de iterações do Ateams
[tentAteams] = 100		// Tentativas sem melhora
[maxTempoAteams] = 10000	// Tempo máximo de execução
[numThreads] = 4                // Número máximo de threads ativas
[tamPopAteams] = 500		// Tamanho da população
[critUnicidade] = 1		// Critério para se definir a unicidade da população
[makespanBest] = -1		// Melhor makespan conhecido


##(SA)#
(name) = SA1
[probSA] = 35			// Probabilidade de se executar SA em cada iteração do ATEAMS
[polEscolhaSA] = 250		// Política de escolha
[maxIterSA] = 250		// Número de iterações para atingir o equilíbrio
[initTempSA] = 125		// Temperatura inicial
[finalTempSA] = 0.75		// Temperatura final
[restauraSolSA] = 0		// Restaura a solução para o mínimo de cada iteração
[alphaSA] = 0.99		// Índice de redução da temperatura

##(SA)#
(name) = SA2
[probSA] = 6			// Probabilidade de se executar SA em cada iteração do ATEAMS
[polEscolhaSA] = 10		// Política de escolha
[maxIterSA] = 250		// Número de iterações para atingir o equilíbrio
[initTempSA] = 125		// Temperatura inicial
[finalTempSA] = 0.75		// Temperatura final
[restauraSolSA] = 0		// Restaura a solução para o mínimo de cada iteração
[alphaSA] = 0.999		// Índice de redução da temperatura

##(SA)#
(name) = SA3
[probSA] = 6			// Probabilidade de se executar SA em cada iteração do ATEAMS
[polEscolhaSA] = 10		// Política de escolha
[maxIterSA] = 25000		// Número de iterações para atingir o equilíbrio
[initTempSA] = 125		// Temperatura inicial
[finalTempSA] = 0.75		// Temperatura final
[restauraSolSA] = 0		// Restaura a solução para o mínimo de cada iteração
[alphaSA] = 0.9			// Índice de redução da temperatura

##(BT)#
(name) = BT1
[probBT] = 20			// Probabilidade de se executar BT em cada iteração do ATEAMS
[polEscolhaBT] = 500		// Política de escolha
[funcAspiracaoBT] = 0.5		// Função de Aspiração
[iterBT] = 750			// Iterações do BT
[tentSemMelhoraBT] = 500	// Política de leitura do BT
[tamListaBT] = 10		// Tamanho de lista do BT
[polExplorBT] = 0.5		// Política na exploração da vizinhança

##(BT)#
(name) = BT2
[probBT] = 10			// Probabilidade de se executar BT em cada iteração do ATEAMS
[polEscolhaBT] = 50		// Política de escolha
[funcAspiracaoBT] = 0.5		// Função de Aspiração
[iterBT] = 750			// Iterações do BT
[tentSemMelhoraBT] = 750	// Política de leitura do BT
[tamListaBT] = 25		// Tamanho de lista do BT
[polExplorBT] = 1		// Política na exploração da vizinhança

##(BT)#
(name) = BT3
[probBT] = 10			// Probabilidade de se executar BT em cada iteração do ATEAMS
[polEscolhaBT] = 250		// Política de escolha
[funcAspiracaoBT] = 0.5		// Função de Aspiração
[iterBT] = 750			// Iterações do BT
[tentSemMelhoraBT] = 750	// Política de leitura do BT
[tamListaBT] = 250		// Tamanho de lista do BT
[polExplorBT] = 0.25		// Política na exploração da vizinhança

##(AG)#
(name) = AG1
[probAG] = 9			// Probabilidade de se executar AG em cada iteração do ATEAMS
[polEscolhaAG] = -1		// Política de escolha
[iterAG] = 500			// Iterações do AG
[tamPopAG] = 250		// Tamanho da população intermediária do AG
[tamParticaoAG] = -1		// Tamanho de uma divisão durante o Crossover ('-1' -> Apenas um pivô; '0' -> Metade do tamanho
[probCrossOverAG] = 0.8		// Probabilidade de cruzamento
[powerCrossOver] = 0.25		// Força do CrossOver
[probMutacaoAG] = 0.08		// Probabilidade de haver mutação

##(AG)#
(name) = AG2
[probAG] = 4			// Probabilidade de se executar AG em cada iteração do ATEAMS
[polEscolhaAG] = -1		// Política de escolha
[iterAG] = 1000			// Iterações do AG
[tamPopAG] = 500		// Tamanho da população intermediária do AG
[tamParticaoAG] = 0		// Tamanho de uma divisão durante o Crossover ('-1' -> Apenas um pivô; '0' -> Metade do tamanho
[probCrossOverAG] = 0.8		// Probabilidade de cruzamento
[powerCrossOverAG] = 1		// Força do CrossOver
[probMutacaoAG] = 0.2		// Probabilidade de haver mutação
